---
title: "Data manipulation"
author: ""
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Aims of this worksheet

One of the key reasons to use R is to be able to manipulate data with ease. After completing this worksheet you will be able to use the data manipulation verbs provided by the [dplyr](https://cran.rstudio.com/web/packages/dplyr/) and [tidyr](https://cran.rstudio.com/web/packages/tidyr/) packages. In addition, you will learn how to read a CSV file into R, and learn how to use the pipe operator. 

Since these packages were written by Hadley Wickham, you may find his articles on "[Tidy Data](http://www.jstatsoft.org/v59/i10/)" and "[The Split-Apply-Combine Strategy for Data Analysis](http://www.jstatsoft.org/article/view/v040i01)" to be useful. In addition, you should read the package documentation and vignettes for the [dplyr](https://cran.rstudio.com/web/packages/dplyr/) package.

## Loading CSV files

We will begin by loading the necessary packages:

```{r, message=FALSE}
library(dplyr)
library(tidyr)
library(historydata)
```

So far we have worked almost exclusively with data which is contained in R packages, which we can install and then load. However, most data will come to you outside of an R package, so you must learn how to load that data. 

Often tabular data will come to you in the form of a CSV (comma separated values) file. This is a text file where, as the name indicates, the columns in the data are separated with columns. This is a much better way of receiving data than say, an Excel spreadsheet.

R has a number of functions that can read in data in various formats. We will use one, `read_csv()`, from the [readr](https://cran.rstudio.com/web/packages/readr/) package, which works nicely with dplyr and tidyr. But there is an equivalent function in base R called `read.csv()`. See `?readr::read_csv` or `?read.csv` for details.

Because R is awesome, we can pass it the URL to a file (in addition to the local path to a file) and it will be loaded. (You could also download the file with `download.file()`.)

```{r}
library(readr)
methodists <- read_csv("http://lincolnmullen.com/projects/worksheets/data/methodists.csv")
```

## The pipe (`%>%`)

The packages that we will be working with all take advantage of an operator provided by the [magrittr](https://cran.rstudio.com/web/packages/magrittr/) package. Called the pipe, this operator `%>%` passes the output of one function to the first argument of a second function.

Consider this example from an earlier exercise, where we find the earliest and latest dates from a column in a data frame. 

```{r}
range(as.Date(naval_promotions$date), na.rm = TRUE)
```

Here we have to read the expression from the inside out, from the `naval_promotions$date`, to the `as.Date()` function, to the `range()` function. The pipe operator lets us write an equivalent expression which is more legible.

```{r}
naval_promotions$date %>% 
  as.Date() %>% 
  range(na.rm = TRUE)
```

## Selecting columns (`select()`)

Now we can begin to use the Methodists data. This data contains membership statistics for different churches, circuits, and class meetings. (This data is transcribed from the Methodist annual minutes meeting, and so it uses the racial terminology from those primary sources.) First can get a sense of what the data looks like.

```{r}
methodists
```

The first data manipulation verb that we are going to use is `select()`. This function lets us pass the names of the columns that we want to keep. 

```{r}
methodists %>% 
  select(minutes_year, meeting, members_general)
```

Notice that we have not actually changed the data stored in `methodists` until we assign the changed data back to the variable.

Read the documentation for this function, `?select`.

(@) Select the `minutes_year`, `meeting`, and all the columns that begin with the word `members_`.

```{r}

```

(@) Remove the column `url`.

```{r}

```

## Filtering rows (`filter()`)

The `select()` function lets us pick certain columns. The `filter()` function lets select certain rows based on logical conditions. For example, here we get the only the churches where the total number of members is at greater than 1,000.

```{r}
methodists %>% 
  filter(members_general > 1000)
```

(@) Get just the rows from New York in 1800.

```{r}

```

(@) Which Methodist meetings had only black members?

```{r}

```


The Methodists gradually kept more detailed records. They began by keeping track of the total number of members, then the number of white and black members, and eventually the number of white, black, and Indian members. But when they kept track of those racial divisions, they did not report the total number of members.

(@) In which year did the Methodists start keeping track of white and black members? (Hint: use `is.na()` to find when the missing values begin.)

```{r}

```

(@) Bonus: some of these Methodist meetings were "missions." Load the `stringr` package and look at the documentation for `?str_detect`. Can you find which rows represent missions?

```{r}

```

## Creating new columns (`mutate()`)

Very often one will want to create a new column based on other columns in the data. For instance, in our Methodist data, there is a column called `minutes_year` for the year that the minutes were kept. But the actual data was for the *previous* year. Here we create a new column called `year`, where each value is one less than in `minutes_year`.

```{r}
methodists %>% 
  mutate(year = minutes_year - 1) %>% 
  select(minutes_year, year, meeting)
```

Notice that we chained the data manipulation functions using the pipe (`%>%`). This lets us create a pipeline were we can do many different manipulations in a row.

(@) Filter the Methodists data to 1786 and later. All of the `members_total` values for those years are `NA`. Assign the the value of `members_white` plus `members_colored` to the `members_total` column.

```{r}

```

(@) Create two new columns, one with the percentage of white members, and one with the percentage of black members.

```{r}

```

(@) Bonus: We neglected the column `members_indian` above, which should be counted in the `members_total` column. However, for some years the values of that column are `NA`, and in other years they have a numeric value. The difference is that the years where the value is `NA`, that column does not appear in the data because it was not tracked. How can you add that column to the total without running into problems with the missing values? (Hints: One way to do this is to use the `ifelse()` function to conditionally assign a value to `members_total`. Another way to do this is to group the data frame using `rowwise()` and use `sum()` with the `na.rm = TRUE` argument. A third, less elegant way, would be to split the data frame manually based on whether the value is `NA` or not, then recombine them.)

## Sorting columns (`arrange()`)

Often we want to sort a data frame by one of its columns. This can be done with the verb `arrange()`. By default `arrange()` will sort from least to greatest; we can use the function `desc()` to sort from greatest to least. In this example, we sort the data frame to get the circuits with the highest number of white members.

```{r}
methodists %>% 
  arrange(desc(members_white))
```

(@) Which circuits had the highest number of black members? Be sure to select only the necessary columns so that the results print in a meaningful way.

```{r}

```

(@) Which circuits had the most members overall? Keep in mind that you will have to use your code from above to calculate the total members for years where that value is `NA` because only the number of white and black members is supplied?

```{r}

```

(@) Which circuits had the high percentage of black members without being entirely black?

```{r}

```

## Split-apply-combine (`group_by()`)

Notice that in the example above the `arrange()` function sorted the entire data frame. So when we looked for the 
